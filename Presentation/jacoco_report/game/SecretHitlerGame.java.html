<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecretHitlerGame.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">1</a> &gt; <a href="index.source.html" class="el_package">game</a> &gt; <span class="el_source">SecretHitlerGame.java</span></div><h1>SecretHitlerGame.java</h1><pre class="source lang-java linenums">package game;

import game.datastructures.Deck;
import game.datastructures.Identity;
import game.datastructures.Player;
import game.datastructures.Policy;
import game.datastructures.board.Board;
import game.datastructures.board.FiveToSixPlayerBoard;
import game.datastructures.board.NineToTenPlayerBoard;
import game.datastructures.board.SevenToEightPlayerBoard;

import java.io.Serializable;
import java.util.*;

/**
 * Keeps track of the state of a game of Secret Hitler.
 *
 * Secret Hitler is a social deduction game for 5-10 players, originally
 * created by Goat, Wolf {@literal &amp;} Cabbage (c) 2016. You can find more details on their
 * website, or order the physical game, at https://www.secrethitler.com/.
 *
 * Secret Hitler is licensed through Creative Commons.
 */
public class SecretHitlerGame implements Serializable {

    /////////////////// Static Fields
    //&lt;editor-fold desc=&quot;Static Fields&quot;&gt;

    // Keeps track of the number of fascists that should be in the game for a given number
    // of players.                                         -   -   -   -   -   5   6   7   8   9  10
<span class="fc" id="L31">    public static final int[] NUM_FASCISTS_FOR_PLAYERS = {-1, -1, -1, -1, -1,  1,  1,  2,  2,  3,  3};</span>

    // The number of fascist and liberal policies in a standard deck.
    public static final int NUM_FASCIST_POLICIES = 11;
    public static final int NUM_LIBERAL_POLICIES = 6;

    public static final int MIN_PLAYERS = 5;
    public static final int MAX_PLAYERS = 10;

    public static final int MAX_FAILED_ELECTIONS = 3;
    private static final float VOTING_CUTOFF = 0.5000001f;
    private static final int MIN_DRAW_DECK_SIZE = 3;

    public static final int PRESIDENT_DRAW_SIZE = 3;
    public static final int CHANCELLOR_DRAW_SIZE = 2;

    //&lt;/editor-fold&gt;

    /////////////////// Private Fields
    //&lt;editor-fold desc=&quot;Private Fields&quot;&gt;

    private List&lt;Player&gt; playerList;
    private Board board;
    private Deck discard;
    private Deck draw;

    private int electionTracker;

    private GameState state;
<span class="fc" id="L60">    private GameState lastState = GameState.SETUP;</span>

    private Random random;

    // The last president and chancellor that were successfully voted into office.
    private String lastPresident;
    private String lastChancellor;

    private String currentPresident;
    private String currentChancellor;

    // Used during a session with the PRESIDENTIAL_POWER_ELECTION power active to remember the next president.
    // The default state should be null.
    private String nextPresident;
    // The president that was elected to take power next (due to the PRESIDENTIAL_POWER_ELECTION power being active).
    private String electedPresident;

    // The player that was targeted with the last presidential power.
    private String target;

    // The options available to either the President or the Chancellor during the legislative session
    private List&lt;Policy&gt; legislativePolicies;

<span class="fc" id="L83">    private boolean didElectionTrackerAdvance = false;</span>

    private HashMap&lt;String, Boolean&gt; voteMap;

    //&lt;/editor-fold&gt;

    /////////////////// Public Observers
    //&lt;editor-fold desc=&quot;Public Observers&quot;&gt;

<span class="fc" id="L92">    public GameState getLastState() { return lastState; }</span>

<span class="fc" id="L94">    public String getTarget() { return target; }</span>

<span class="fc" id="L96">    public String getCurrentPresident() { return currentPresident; }</span>

<span class="fc" id="L98">    public String getCurrentChancellor() { return currentChancellor; }</span>

<span class="fc" id="L100">    public String getLastPresident() { return lastPresident; }</span>

<span class="fc" id="L102">    public String getLastChancellor() { return lastChancellor; }</span>

<span class="fc" id="L104">    public int getDrawSize() { return draw.getSize(); }</span>

<span class="fc" id="L106">    public int getDiscardSize() { return discard.getSize(); }</span>

<span class="fc" id="L108">    public int getElectionTracker() { return electionTracker; }</span>

<span class="fc" id="L110">    public int getNumFascistPolicies() { return board.getNumFascistPolicies(); }</span>

<span class="fc" id="L112">    public int getNumLiberalPolicies() { return board.getNumLiberalPolicies(); }</span>

<span class="fc" id="L114">    public boolean didElectionTrackerAdvance() { return didElectionTrackerAdvance; }</span>

    //&lt;/editor-fold&gt;

    /////////////////// Constructor
    //&lt;editor-fold desc=&quot;Constructor&quot;&gt;

    /**
     * Constructs a new game of Secret Hitler with the given players.
     * @param players the names of the players to add to the game.
     * @requires there can be no repeat names in {@code players}. The number of players must be between MIN_PLAYERS and
     *           MAX_PLAYERS, inclusive.
     * @modifies this
     * @effects this is a new game.SecretHitlerGame in setup mode with no players.
     */
<span class="fc" id="L129">    public SecretHitlerGame(Collection&lt;String&gt; players) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (players.size() &lt; MIN_PLAYERS) {</span>
<span class="fc" id="L131">            throw new IllegalArgumentException(&quot;There must be at least &quot; + MIN_PLAYERS + &quot; to start the game (only &quot; + players.size() + &quot; provided).&quot;);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        } else if (players.size() &gt; MAX_PLAYERS) {</span>
<span class="fc" id="L133">            throw new IllegalArgumentException(&quot;There can be a max of &quot; + MAX_PLAYERS + &quot; in a game (&quot; + players.size() + &quot; provided).&quot;);</span>
        }

        // Set up the list of players.
<span class="fc" id="L137">        playerList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (String name : players) {</span>
<span class="fc" id="L139">            playerList.add(new Player(name));</span>
<span class="fc" id="L140">        }</span>

<span class="fc" id="L142">        state = GameState.SETUP;</span>
<span class="fc" id="L143">        random = new Random();</span>
<span class="fc" id="L144">        electionTracker = 0;</span>
<span class="fc" id="L145">        voteMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L146">        start();</span>
<span class="fc" id="L147">    }</span>

    //&lt;/editor-fold&gt;

    /////////////////// Player Management
    //&lt;editor-fold desc=&quot;Player Management&quot;&gt;


    /**
     * Checks if the game has a player with the given username.
     * @param username the String username of the player to search for.
     * @return true iff the player is in the game.
     */
    public boolean hasPlayer(String username) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (Player p : playerList) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (p.getUsername().equals(username)) {</span>
<span class="fc" id="L163">                return true;</span>
            }
<span class="fc" id="L165">        }</span>
<span class="fc" id="L166">        return false;</span>
    }

    /**
     * Gets the list of active players.
     * @return an immutable list of Players.
     */
    public List&lt;Player&gt; getPlayerList() {
<span class="fc" id="L174">        return new ArrayList&lt;&gt;(playerList);</span>
    }

    /**
     * Gets the index of a player in the list.
     * @param username the username to search for.
     * @return the index of the given player in the list. Returns -1 if the player was not found.
     */
    private int indexOfPlayer(String username) {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        for(int i = 0; i &lt; playerList.size(); i++) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (playerList.get(i).getUsername().equals(username)) {</span>
<span class="fc" id="L185">                return i;</span>
            }
        }
<span class="nc" id="L188">        return -1;</span>
    }

    private Player getPlayer(String username) {
<span class="fc" id="L192">        return playerList.get(indexOfPlayer(username));</span>
    }

    //&lt;/editor-fold&gt;

    /////////////////// Game Setup
    //&lt;editor-fold desc=&quot;Game Setup&quot;&gt;

    /**
     * Starts the game of Secret Hitler.
     * @modifies this
     * @effects initializes the game, setting all player identities and card decks. The first player in the provided
     *          player list is the first president, and the game begins the chancellor nomination process.
     */
    private void start() {
<span class="fc" id="L207">        resetDeck();</span>
<span class="fc" id="L208">        assignRoles();</span>
<span class="fc" id="L209">        electionTracker = 0;</span>

        // Assign a new board based on the number of players.
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (playerList.size() &lt;= 6) {</span>
<span class="fc" id="L213">            board = new FiveToSixPlayerBoard();</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        } else if (playerList.size() &lt;= 8) {</span>
<span class="nc" id="L215">            board = new SevenToEightPlayerBoard();</span>
        } else {
<span class="fc" id="L217">            board = new NineToTenPlayerBoard();</span>
        }

<span class="fc" id="L220">        currentPresident = playerList.get(0).getUsername();</span>
<span class="fc" id="L221">        currentChancellor = null;</span>
<span class="fc" id="L222">        lastChancellor = null;</span>
<span class="fc" id="L223">        lastPresident = null;</span>

<span class="fc" id="L225">        state = GameState.CHANCELLOR_NOMINATION;</span>
<span class="fc" id="L226">    }</span>

    /**
     * Resets the Draw and Discard decks.
     * @effects empties the discard deck, fills the draw deck with a standard card count, and shuffles.
     */
    private void resetDeck() {
<span class="fc" id="L233">        draw = new Deck();</span>
<span class="fc" id="L234">        discard = new Deck();</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_FASCIST_POLICIES; i++) {</span>
<span class="fc" id="L237">            draw.add(new Policy(Policy.Type.FASCIST));</span>
        }
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_LIBERAL_POLICIES; i++) {</span>
<span class="fc" id="L240">            draw.add(new Policy(Policy.Type.LIBERAL));</span>
        }

<span class="fc" id="L243">        draw.shuffle();</span>
<span class="fc" id="L244">    }</span>

    /**
     * Randomly assigns the player roles.
     * @requires the number of players is between 5 and 10, inclusive.
     * @modifies this
     * @effects all Players in playerList are assigned either LIBERAL, FASCIST, or HITLER.
     *          The number of each is given by the following table:
     *          # players:  5   6   7   8   9   10
     *          # liberals: 3   4   4   5   5   6
     *          # fascists: 1   1   2   2   3   3
     *          # hitler:   1   1   1   1   1   1
     */
    private void assignRoles() {
<span class="fc" id="L258">        int players = playerList.size();</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (players &lt; MIN_PLAYERS) {</span>
<span class="nc" id="L260">            throw new IllegalStateException(&quot;Cannot assign roles with insufficient players.&quot;);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        } else if (players &gt; MAX_PLAYERS) {</span>
<span class="nc" id="L262">            throw new IllegalStateException(&quot;Cannot assign roles with too many players.&quot;);</span>
        }

                                            // 5  6  7  8  9  10
<span class="fc" id="L266">        int[] fascistsFromPlayers = new int[] {1, 1, 2, 2, 3, 3};</span>
<span class="fc" id="L267">        int numFascistsToSet = fascistsFromPlayers[players - MIN_PLAYERS];</span>

        // Set all players to default state
<span class="fc bfc" id="L270" title="All 2 branches covered.">        for (Player player : playerList) {</span>
<span class="fc" id="L271">            player.setIdentity(Identity.LIBERAL);</span>
<span class="fc" id="L272">        }</span>

        //Randomly set one player to be hitler
<span class="fc" id="L275">        int indexOfHitler = random.nextInt(players);</span>
<span class="fc" id="L276">        playerList.get(indexOfHitler).setIdentity(Identity.HITLER);</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">        while (numFascistsToSet &gt; 0) {</span>
<span class="fc" id="L279">            int randomIndex = random.nextInt(players);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            if (!playerList.get(randomIndex).isFascist()) { //If player has not already been set</span>
<span class="fc" id="L281">                playerList.get(randomIndex).setIdentity(Identity.FASCIST);</span>
<span class="fc" id="L282">                numFascistsToSet--;</span>
            }
<span class="fc" id="L284">        }</span>
<span class="fc" id="L285">    }</span>

    //&lt;/editor-fold&gt;

    /////////////////// State Management
    //&lt;editor-fold desc=&quot;State Management&quot;&gt;


    /**
     * Gets the current state of the game.SecretHitlerGame.
     * @return a game.GameState representing the current state of the game.
     */
    public GameState getState() {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (board != null) {</span>
<span class="fc" id="L299">            checkIfGameOver();</span>
        }
<span class="fc" id="L301">        return state;</span>
    }

    /**
     * Updates the game state if the game ended by policies.
     * @modifies this
     * @effects sets this.state to the FASCIST_VICTORY_POLICY or LIBERAL_VICTORY_POLICY states if the
     *          win conditions for policies are met.
     */
    private void checkIfGameOver() {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if(board.isFascistVictory()) {</span>
<span class="nc" id="L312">            this.lastState = this.state;</span>
<span class="nc" id="L313">            state = GameState.FASCIST_VICTORY_POLICY;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        } else if (board.isLiberalVictory()) {</span>
<span class="nc" id="L315">            this.lastState = this.state;</span>
<span class="nc" id="L316">            state = GameState.LIBERAL_VICTORY_POLICY;</span>
        }
<span class="fc" id="L318">    }</span>

    /**
     * Adds the discard deck to the draw deck and shuffles.
     * @modifies this
     * @effects Empties the discard pile into the draw pile and shuffles.
     */
    private void shuffleDiscardIntoDraw() {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        while(!discard.isEmpty()) {</span>
<span class="nc" id="L327">            draw.add(discard.remove());</span>
        }
<span class="nc" id="L329">        draw.shuffle();</span>
<span class="nc" id="L330">    }</span>

    //&lt;/editor-fold&gt;

    /////////////////// Nomination and Voting
    //&lt;editor-fold desc=&quot;Nomination and Voting&quot;&gt;

    /**
     * Selects the chancellor for the current legislation.
     * @param username username of the chancellor to elect.
     * @throws IllegalStateException if the state is not {@code CHANCELLOR_SELECTION}.
     * @throws IllegalArgumentException if the player named {@code username} was the last elected chancellor, if
     *         there are &gt;5 players and they are the last elected president, if the player is dead,
     *         or if the player does not exist.
     * @modifies this
     * @effects the current chancellor is set to the player named {@code username}. The game state is set to be in
     *          CHANCELLOR_VOTING.
     */
    public void nominateChancellor(String username) {
<span class="fc" id="L349">        int numLivingPlayers = 0;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (Player player : playerList) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            if (player.isAlive())</span>
<span class="fc" id="L352">                numLivingPlayers++;</span>
<span class="fc" id="L353">        }</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (getState() != GameState.CHANCELLOR_NOMINATION) {</span>
<span class="fc" id="L356">            throw new IllegalStateException(&quot;Cannot elect a chancellor now (invalid state).&quot;);</span>
<span class="pc bpc" id="L357" title="4 of 6 branches missed.">        } else if (username.equals(lastChancellor) || (username.equals(lastPresident) &amp;&amp; numLivingPlayers &gt; 5)) {</span>
<span class="nc" id="L358">            throw new IllegalArgumentException(&quot;Cannot elect chancellor that was previously in office.&quot;);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        } else if (!hasPlayer(username)) {</span>
<span class="fc" id="L360">            throw new IllegalArgumentException(&quot;Player &quot; + username + &quot; does not exist.&quot;);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        } else if (!getPlayer(username).isAlive()) {</span>
<span class="fc" id="L362">            throw new IllegalArgumentException(&quot;Player &quot; + username + &quot; is dead and cannot be elected for chancellor.&quot;);</span>
        }

<span class="fc" id="L365">        didElectionTrackerAdvance = false; // reset the election tracker</span>
<span class="fc" id="L366">        currentChancellor = username;</span>
<span class="fc" id="L367">        this.lastState = this.state;</span>
<span class="fc" id="L368">        state = GameState.CHANCELLOR_VOTING; // exits the previous state.</span>
<span class="fc" id="L369">        voteMap = new HashMap&lt;&gt;(); // initializes a new map for voting.</span>
<span class="fc" id="L370">    }</span>

    /**
     * Registers a vote for chancellor from a given player.
     * @param username the name of the player giving the vote.
     * @param vote the vote of the player (true = ja, false = nein).
     * @throws IllegalArgumentException if the Player with name {@code username} is not in the game.
     * @throws IllegalStateException if the Player with name {@code username} has already voted, or if the game is not
     *                               in the voting ({@code CHANCELLOR_VOTING}) state.
     * @modifies this
     * @effects registers the given vote. If all players have voted, determines whether the vote passed.
     *          If the vote passed, the state advances to {@code LEGISLATIVE_PRESIDENT}. (unless the chancellor is Hitler
     *          and three fascist policies have been passed, in which case the state advances to {@code FASCIST_VICTORY_ELECTION.}
     *          If the vote did not pass, advances the election tracker by 1. If the election tracker reaches its max,
     *          immediately enacts the top policy on the pile and handles state progression.
     */
    public void registerVote(String username, boolean vote) {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if(!hasPlayer(username)) {</span>
<span class="fc" id="L388">            throw new IllegalArgumentException(&quot;Player &quot; + username +&quot; is not in the game and cannot vote.&quot;);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        } else if (voteMap.containsKey(username)) {</span>
<span class="fc" id="L390">            throw new IllegalStateException(&quot;Player &quot; + username + &quot; cannot vote twice.&quot;);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">        } else if (state != GameState.CHANCELLOR_VOTING) {</span>
<span class="fc" id="L392">            throw new IllegalStateException(&quot;Player &quot; + username + &quot; cannot vote when a vote is not taking place.&quot;);</span>
        }

<span class="fc" id="L395">        voteMap.put(username, vote);</span>

        // Count up votes and check if all votes have been submitted.
<span class="fc" id="L398">        boolean allPlayersHaveVoted = true;</span>
<span class="fc" id="L399">        int totalVotes = 0;</span>
<span class="fc" id="L400">        int totalYesVotes = 0;</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (Player player : playerList) {</span>
<span class="fc" id="L403">            String playerName = player.getUsername();</span>

<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (player.isAlive()) { // only account for</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (voteMap.containsKey(playerName)) {</span>
<span class="fc" id="L407">                    totalVotes += 1;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                    if (voteMap.get(playerName)) { // player voted yes</span>
<span class="fc" id="L409">                        totalYesVotes += 1;</span>
                    }
                } else {
<span class="fc" id="L412">                    allPlayersHaveVoted = false; //Player vote not accounted for</span>
                }
            }
<span class="fc" id="L415">        }</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (allPlayersHaveVoted) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (((float) totalYesVotes / (float) totalVotes) &gt; VOTING_CUTOFF) { // vote passed successfully</span>
<span class="fc" id="L419">                lastChancellor = currentChancellor;</span>
<span class="fc" id="L420">                lastPresident = currentPresident;</span>
<span class="pc bpc" id="L421" title="1 of 4 branches missed.">                if (getPlayer(currentChancellor).isHitler() &amp;&amp; board.fascistsCanWinByElection()) {</span>
<span class="nc" id="L422">                    this.lastState = this.state;</span>
<span class="nc" id="L423">                    state = GameState.FASCIST_VICTORY_ELECTION; // Fascists won by electing Hitler: game ends.</span>
                } else {
<span class="fc" id="L425">                    startLegislativeSession();</span>
                }
            } else { // vote failed
<span class="fc" id="L428">                advanceElectionTracker();</span>
            }
        }
<span class="fc" id="L431">    }</span>

    /**
     * Returns a map representing what each player voted.
     * @return a map, where the keys are the usernames and the booleans are the vote (yes/no) of the player.
     */
    public Map&lt;String, Boolean&gt; getVotes() {
<span class="fc" id="L438">        return new HashMap&lt;&gt;(voteMap); // making a copy of the votes so that they cannot be externally modified</span>
    }

    /**
     * Advances the election tracker and enacts a policy if needed.
     * @modifies this
     * @effects If the tracker &lt; 2, advances the tracker by 1.
     *          If the tracker == 2, rests the tracker to 0 and enacts the first policy on the top of the draw pile.
     */
    private void advanceElectionTracker() {
<span class="fc" id="L448">        didElectionTrackerAdvance = true;</span>
<span class="fc" id="L449">        electionTracker += 1;</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (electionTracker == MAX_FAILED_ELECTIONS) {</span>
<span class="nc" id="L451">            Policy newPolicy = draw.remove();</span>
<span class="nc" id="L452">            board.enactPolicy(newPolicy);</span>
            // Note that the newPolicy is NOT added back to the discard pile.
<span class="nc" id="L454">            electionTracker = 0; // Reset</span>

<span class="nc" id="L456">            onEnactPolicy();</span>
<span class="nc" id="L457">        } else {</span>
<span class="fc" id="L458">            concludePresidentialActions();</span>
        }
<span class="fc" id="L460">    }</span>

    //&lt;/editor-fold&gt;

    /////////////////// President Management
    // &lt;editor-fold desc=&quot;President Management&quot;&gt;
    /**
     * Called when the president's actions are over.
     * @modifies this
     * @effects advances the state to {@code POST_LEGISLATIVE}.
     */
    private void concludePresidentialActions() {
<span class="fc" id="L472">        this.lastState = this.state;</span>
<span class="fc" id="L473">        this.state = GameState.POST_LEGISLATIVE;</span>
<span class="fc" id="L474">    }</span>

    /**
     * Called to end the current's president term.
     * @throws IllegalStateException if the state is not {@code POST_LEGISLATIVE}.
     * @modifies this
     * @effects advances the state to {@code CHANCELLOR_NOMINATION} and updates the current president.
     *          If the PRESIDENTIAL_POWER_ELECTION power was activated, sets the next president to the elected.
     *          If the election round finished, returns to the next player in the normal round ordering.
     *          Otherwise, chooses the next eligible (alive) player in the ordering to become president.
     */
    public void endPresidentialTerm() {
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (this.state != GameState.POST_LEGISLATIVE) {</span>
<span class="fc" id="L487">            throw new IllegalStateException();</span>
        }

<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (electedPresident != null) { // If the PRESIDENTIAL_POWER_ELECTION was active, chooses the elected president.</span>
<span class="nc" id="L491">            currentPresident = electedPresident;</span>
<span class="nc" id="L492">            electedPresident = null;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        } else if (nextPresident != null) { // Once the PRESIDENTIAL_POWER_ELECTION round concludes, returns to the normal order.</span>
<span class="nc" id="L494">            currentPresident = nextPresident;</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            while (!getPlayer(currentPresident).isAlive()) {</span>
                // Advance to the next president
<span class="nc" id="L497">                int presIndex = indexOfPlayer(currentPresident);</span>
<span class="nc" id="L498">                currentPresident = getPlayerList().get(presIndex + 1).getUsername();</span>
<span class="nc" id="L499">            }</span>
<span class="nc" id="L500">            nextPresident = null;</span>
        } else { // advance the presidency
            // Advance presidency:
<span class="fc" id="L503">            currentPresident = getNextActivePlayer(currentPresident);</span>
        }
<span class="fc" id="L505">        currentChancellor = null;</span>
<span class="fc" id="L506">        this.lastState = this.state;</span>
<span class="fc" id="L507">        this.state = GameState.CHANCELLOR_NOMINATION;</span>
<span class="fc" id="L508">    }</span>

    /**
     * Finds the next active, living player in order.
     * @param player the player to find the next active player from.
     * @return the username of the next player in order. Returns null if no player was found.
     */
    private String getNextActivePlayer(String player) {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        for(int i = 1; i &lt; playerList.size(); i++) {</span>
<span class="fc" id="L517">            int index = (i + indexOfPlayer(player)) % playerList.size();</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (playerList.get(index).isAlive()) {</span>
<span class="fc" id="L519">                return playerList.get(index).getUsername();</span>
            }
        }
<span class="nc" id="L522">        return null;</span>
    }

    // &lt;/editor-fold&gt;

    /////////////////// Legislative Session
    // &lt;editor-fold desc=&quot;Legislative Session&quot;&gt;

    /**
     * Starts the legislative session.
     * Sets the available policies and the game state.
     */
    private void startLegislativeSession() {
<span class="fc" id="L535">        this.lastState = this.state;</span>
<span class="fc" id="L536">        state = GameState.LEGISLATIVE_PRESIDENT; // Legislative session begins.</span>

<span class="fc" id="L538">        legislativePolicies = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; PRESIDENT_DRAW_SIZE; i++) {</span>
<span class="fc" id="L540">            legislativePolicies.add(draw.remove());</span>
        }
<span class="fc" id="L542">    }</span>

    /**
     * Gets the legislative choices available for the President.
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_PRESIDENT} or if an incorrect
     *                               number of policies is available.
     * @return a list of policies (size of {@code this.PRESIDENT_DRAW_SIZE}) representing the available choices.
     */
    public List&lt;Policy&gt; getPresidentLegislativeChoices() {
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (state != GameState.LEGISLATIVE_PRESIDENT) {</span>
<span class="fc" id="L552">            throw new IllegalStateException(&quot;Cannot get President legislative choices when not in legislative session.&quot;);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        } if (legislativePolicies.size() != PRESIDENT_DRAW_SIZE) {</span>
<span class="nc" id="L554">            throw new IllegalStateException(&quot;An incorrect number of legislative policies are available for the president (&quot;</span>
<span class="nc" id="L555">                                            + legislativePolicies.size() + &quot; instead of &quot; + PRESIDENT_DRAW_SIZE);</span>
        }
<span class="fc" id="L557">        return new ArrayList&lt;&gt;(legislativePolicies); // makes a copy of the legislative policies</span>
    }

    /**
     * Discards the Policy in the list of presidential policy options.
     * @param index the index of the policy in the list of legislative choices to enact.
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_PRESIDENT}.
     * @throws IndexOutOfBoundsException if index is outside of range [0, 2] (inclusive).
     * @modifies this
     * @effects adds the card in the policy list at index {@code index} to the discard deck.
     *          Advances state to the {@code LEGISLATIVE_CHANCELLOR} state.
     */
    public void presidentDiscardPolicy(int index) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (state != GameState.LEGISLATIVE_PRESIDENT) {</span>
<span class="fc" id="L571">            throw new IllegalStateException(&quot;Cannot discard a policy from the president's hand in this state.&quot;);</span>
<span class="fc bfc" id="L572" title="All 4 branches covered.">        } else if (index &lt; 0 || index &gt;= PRESIDENT_DRAW_SIZE) {</span>
<span class="fc" id="L573">            throw new IndexOutOfBoundsException(&quot;Cannot discard policy at the index &quot; + index + &quot;&quot;);</span>
        }
<span class="fc" id="L575">        discard.add(legislativePolicies.remove(index));</span>
<span class="fc" id="L576">        this.lastState = this.state;</span>
<span class="fc" id="L577">        state = GameState.LEGISLATIVE_CHANCELLOR;</span>
<span class="fc" id="L578">    }</span>

    /**
     * Gets the legislative choices available for the Chancellor.
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_CHANCELLOR}.
     * @return a list of policies (size of {@code this.CHANCELLOR_DRAW_SIZE}) representing the available choices.
     */
    public List&lt;Policy&gt; getChancellorLegislativeChoices() {
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (getState() != GameState.LEGISLATIVE_CHANCELLOR) {</span>
<span class="nc" id="L587">            throw new IllegalStateException(&quot;Cannot get Chancellor legislative choices when not in legislative session.&quot;);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        } if (legislativePolicies.size() != CHANCELLOR_DRAW_SIZE) {</span>
<span class="nc" id="L589">            throw new IllegalStateException(&quot;An incorrect number of legislative policies are available for the chancellor (&quot;</span>
<span class="nc" id="L590">                    + legislativePolicies.size() + &quot; instead of &quot; + CHANCELLOR_DRAW_SIZE);</span>
        }
<span class="nc" id="L592">        return new ArrayList&lt;&gt;(legislativePolicies);</span>
    }

    /**
     * Enacts the Policy in the list of chancellor policy options.
     * @param index the index of the policy in the list of legislative choices to enact.
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_CHANCELLOR}.
     * @throws IndexOutOfBoundsException if index is outside of range [0, 2] (inclusive).
     * @modifies this
     * @effects enacts the policy at index {@code index} and discards the remaining card.
     *          Advances state to any relevant presidential powers, otherwise, advances to state {@code POST_LEGISLATIVE}.
     */
    public void chancellorEnactPolicy(int index) {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (getState() != GameState.LEGISLATIVE_CHANCELLOR) {</span>
<span class="fc" id="L606">            throw new IllegalStateException(&quot;Cannot discard a policy from the chancellor's hand in this state.&quot;);</span>
<span class="fc bfc" id="L607" title="All 4 branches covered.">        } else if (index &lt; 0 || index &gt;= CHANCELLOR_DRAW_SIZE) {</span>
<span class="fc" id="L608">            throw new IndexOutOfBoundsException(&quot;Cannot discard policy at the index &quot; + index + &quot;&quot;);</span>
        }

<span class="fc" id="L611">        board.enactPolicy(legislativePolicies.remove(index));</span>
<span class="fc" id="L612">        discard.add(legislativePolicies.remove(0)); //Discard last remaining Policy</span>
<span class="fc" id="L613">        onEnactPolicy();</span>
<span class="fc" id="L614">    }</span>

    /**
     * Marks the chancellor as having vetoed the current policy agenda.
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_CHANCELLOR}
     * @modifies this
     * @effects advances the state to {@code LEGISLATIVE_PRESIDENT_VETO} and awaits the president's approval.
     */
    public void chancellorVeto() {
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (getState() != GameState.LEGISLATIVE_CHANCELLOR) {</span>
<span class="fc" id="L624">            throw new IllegalStateException(&quot;Cannot veto in state &quot; + getState().toString());</span>
        }
<span class="nc" id="L626">        state = GameState.LEGISLATIVE_PRESIDENT_VETO;</span>
<span class="nc" id="L627">    }</span>

    /**
     * Handles the president's response to an initiated veto.
     * @param response is the president's vote (true = veto accepted, false = veto denied)
     * @throws IllegalStateException if called when the state is not {@code LEGISLATIVE_PRESIDENT_VETO}
     * @modifies this
     * @effects If the veto is denied ({@code response} = false), then the game returns to the chancellor's decision
     *          (state = LEGISLATIVE_CHANCELLOR).
     *          If the veto is approved ({@code response} = true), then the game advances the election tracker. If the
     *          tracker is at MAX_FAILED_ELECTIONS, enacts the first policy on top of the draw deck and carries out
     *          any consequences of the policy.
     */
    public void presidentialVeto(boolean response) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (state != GameState.LEGISLATIVE_PRESIDENT_VETO) {</span>
<span class="fc" id="L642">            throw new IllegalStateException(&quot;Cannot get president veto input during state &quot; + getState().toString() + &quot;&quot;);</span>
        }
<span class="nc bnc" id="L644" title="All 2 branches missed.">        if (response) { // veto was approved, advance election tracker</span>
<span class="nc" id="L645">            advanceElectionTracker();</span>
        } else {        // veto was denied, return to chancellor selection
<span class="nc" id="L647">            this.lastState = this.state;</span>
<span class="nc" id="L648">            state = GameState.LEGISLATIVE_CHANCELLOR;</span>
        }
<span class="nc" id="L650">    }</span>

    /**
     * Called AFTER a policy has been enacted, and sets the state according to any consequences.
     * @modifies this
     * @effects sets the state to handle any presidential powers that arise.
     *          Otherwise, state is set to {@code CHANCELLOR_SELECTION}.
     *          Also handles reshuffling the discard into the draw deck when there are insufficient cards for a hand,
     *          and resets the election tracker to 0.
     */
    private void onEnactPolicy() {
<span class="fc" id="L661">        electionTracker = 0;</span>

<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (draw.getSize() &lt; MIN_DRAW_DECK_SIZE) {</span>
<span class="nc" id="L664">            shuffleDiscardIntoDraw();</span>
        }

<span class="fc" id="L667">        this.lastState = this.state;</span>
<span class="pc bpc" id="L668" title="5 of 6 branches missed.">        switch (board.getActivatedPower()) {</span>
            case PEEK:
<span class="nc" id="L670">                state = GameState.PRESIDENTIAL_POWER_PEEK;</span>
<span class="nc" id="L671">                break;</span>
            case EXECUTION:
<span class="nc" id="L673">                state = GameState.PRESIDENTIAL_POWER_EXECUTION;</span>
<span class="nc" id="L674">                break;</span>
            case ELECTION:
<span class="nc" id="L676">                state = GameState.PRESIDENTIAL_POWER_ELECTION;</span>
<span class="nc" id="L677">                break;</span>
            case INVESTIGATE:
<span class="nc" id="L679">                state = GameState.PRESIDENTIAL_POWER_INVESTIGATE;</span>
<span class="nc" id="L680">                break;</span>
            case NONE:
<span class="fc" id="L682">                state = GameState.POST_LEGISLATIVE;</span>
                break;
        }
<span class="fc" id="L685">    }</span>

    //&lt;/editor-fold&gt;

    /////////////////// Presidential Powers
    //&lt;editor-fold desc=&quot;Presidential Powers&quot;&gt;

    /**
     * Gets the preview of the top 3 cards of the deck during the {@code PRESIDENTIAL_POWER_PEEK} state.
     * @throws IllegalStateException if called when state is not {@code PRESIDENTIAL_POWER_PEEK}.
     * @return a size-3 list of Policies, where index 0 is the top of the stack.
     */
    public List&lt;Policy&gt; getPeek() {
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (state != GameState.PRESIDENTIAL_POWER_PEEK) {</span>
<span class="nc" id="L699">            throw new IllegalStateException(&quot;Cannot peek when the power is not active.&quot;);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        } else if (draw.getSize() &lt; 3) {</span>
<span class="nc" id="L701">            throw new IllegalStateException(&quot;Insufficient cards in the draw deck.&quot;);</span>
        }
<span class="nc" id="L703">        List&lt;Policy&gt; policies = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L704">        policies.add(draw.peek(0));</span>
<span class="nc" id="L705">        policies.add(draw.peek(1));</span>
<span class="nc" id="L706">        policies.add(draw.peek(2));</span>
<span class="nc" id="L707">        return policies;</span>
    }

    /**
     * Ends the {@code PRESIDENTIAL_POWER_PEEK} state.
     * @throws IllegalStateException if called when state is not {@code PRESIDENTIAL_POWER_PEEK}.
     * @effects Advances the state to {@code POST_LEGISLATIVE}.
     */
    public void endPeek() {
<span class="nc" id="L716">        concludePresidentialActions();</span>
<span class="nc" id="L717">    }</span>

    /**
     * Investigates the party identity of a given player.
     * @param username the username of the player to investigate.
     * @throws IllegalStateException if called when state is not {@code PRESIDENTIAL_POWER_INVESTIGATE}.
     * @throws IllegalArgumentException if the player is not alive, is not in the game, or has been investigated previously.
     * @return the party membership of the player. If the player is fascist or Hitler, returns Identity.FASCIST.
     *         if the player is liberal, returns Identity.LIBERAL.
     *         Once called, advances the state of the game to POST_LEGISLATIVE.
     */
    public Identity investigatePlayer(String username) {
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (state != GameState.PRESIDENTIAL_POWER_INVESTIGATE) {</span>
<span class="nc" id="L730">            throw new IllegalStateException(&quot;Cannot investigate a player when the power is not active.&quot;);</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        } else if (!hasPlayer(username)) {</span>
<span class="nc" id="L732">            throw new IllegalArgumentException(&quot;Player &quot; + username + &quot; does not exist.&quot;);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        } else if (!getPlayer(username).isAlive()) {</span>
<span class="nc" id="L734">            throw new IllegalArgumentException(&quot;Cannot investigate a dead player (&quot; + username + &quot;).&quot;);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        } else if (getPlayer(username).hasBeenInvestigated()) {</span>
<span class="nc" id="L736">            throw new IllegalArgumentException(&quot;Cannot investigate a player twice (&quot; + username + &quot;).&quot;);</span>
        }

<span class="nc" id="L739">        target = username;</span>
<span class="nc" id="L740">        getPlayer(username).investigate(); // sets a flag that this player has been investigated.</span>
<span class="nc" id="L741">        concludePresidentialActions();</span>

<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (getPlayer(username).isFascist()) {</span>
<span class="nc" id="L744">            return Identity.FASCIST;</span>
        } else {
<span class="nc" id="L746">            return Identity.LIBERAL;</span>
        }
    }

    /**
     * Executes a given player.
     * @param username the username of the player to execute.
     * @throws IllegalStateException if called when state is not {@code PRESIDENTIAL_POWER_EXECUTION}.
     * @throws IllegalArgumentException if the player is already dead or is not in the game.
     * @modifies this
     * @effects The specified player is marked as not alive.
     *          If they were Hitler, advances the state of the game to LIBERAL_VICTORY_EXECUTION.
     *          Otherwise, once called, advances the state of the game to POST_LEGISLATIVE.
     */
    public void executePlayer(String username) {
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (state != GameState.PRESIDENTIAL_POWER_EXECUTION) {</span>
<span class="nc" id="L762">            throw new IllegalStateException(&quot;Cannot execute a player when the power is not active.&quot;);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">        } else if (!hasPlayer(username)) {</span>
<span class="nc" id="L764">            throw new IllegalArgumentException(&quot;Player &quot; + username + &quot; does not exist.&quot;);</span>
        }

<span class="nc" id="L767">        Player playerToKill = getPlayer(username);</span>
<span class="nc" id="L768">        target = username;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">        if (!playerToKill.isAlive()) {</span>
<span class="nc" id="L770">            throw new IllegalArgumentException(&quot;Cannot execute &quot; + username + &quot; because they are not alive.&quot;);</span>
        }

<span class="nc" id="L773">        playerToKill.kill();</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">        if(playerToKill.isHitler()) { // game ends and liberals win.</span>
<span class="nc" id="L775">            this.lastState = this.state;</span>
<span class="nc" id="L776">            state = GameState.LIBERAL_VICTORY_EXECUTION;</span>
        } else {
<span class="nc" id="L778">            concludePresidentialActions();</span>
        }
<span class="nc" id="L780">    }</span>

    /**
     * Sets the next president through the Election power.
     * @param username the username of the player to become president next.
     * @throws IllegalStateException if called when state is not {@code PRESIDENTIAL_POWER_ELECTION}.
     * @throws IllegalArgumentException if the player is dead or is not in the game.
     * @modifies this
     * @effects The specified player becomes the next president.
     *          After the completion of their term, the presidency returns to the next president
     *          in the normal rotation order.
     *          Once called, advances the state to POST_LEGISLATIVE.
     */
    public void electNextPresident(String username) {
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (state != GameState.PRESIDENTIAL_POWER_ELECTION) {</span>
<span class="nc" id="L795">            throw new IllegalStateException(&quot;Cannot elect a player president when the power is not active.&quot;);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        } else if (!hasPlayer(username)) {</span>
<span class="nc" id="L797">            throw new IllegalArgumentException(&quot;Player &quot; + username + &quot; does not exist.&quot;);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">        } else if (!getPlayer(username).isAlive()) {</span>
<span class="nc" id="L799">            throw new IllegalArgumentException(&quot;Cannot elect &quot; + username + &quot; because they are not alive.&quot;);</span>
        }

<span class="nc" id="L802">        target = username;</span>
<span class="nc" id="L803">        nextPresident = getNextActivePlayer(currentPresident);</span>
<span class="nc" id="L804">        electedPresident = username;</span>
<span class="nc" id="L805">        concludePresidentialActions();</span>
<span class="nc" id="L806">    }</span>

    //&lt;/editor-fold&gt;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>